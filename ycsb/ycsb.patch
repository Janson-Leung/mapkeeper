diff --git a/build.xml b/build.xml
index af46342..1e138ac 100644
--- a/build.xml
+++ b/build.xml
@@ -50,6 +50,11 @@
    	    <antcall target="dbcompile"/>
    	</target>
 	
+   	<target name="dbcompile-mapkeeper" depends="compile">
+            <property name="db.dir" value="db/mapkeeper"/>
+   	    <antcall target="dbcompile"/>
+   	</target>
+
  	<target name="compile">
         <mkdir dir="${classes.dir}"/>
         <javac srcdir="${src.dir}" destdir="${classes.dir}" classpathref="build.classpath" deprecation="on">
diff --git a/db/mapkeeper/lib/README b/db/mapkeeper/lib/README
index e69de29..6d3e345 100644
--- a/db/mapkeeper/lib/README
+++ b/db/mapkeeper/lib/README
@@ -0,0 +1 @@
+This directory should contain jars for building and running MapKeeper
diff --git a/db/mapkeeper/src/com/yahoo/ycsb/db/MapKeeperClient.java b/db/mapkeeper/src/com/yahoo/ycsb/db/MapKeeperClient.java
index e69de29..594c930 100644
--- a/db/mapkeeper/src/com/yahoo/ycsb/db/MapKeeperClient.java
+++ b/db/mapkeeper/src/com/yahoo/ycsb/db/MapKeeperClient.java
@@ -0,0 +1,196 @@
+package com.yahoo.ycsb.db;
+
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Properties;
+import java.util.Set;
+import java.util.Vector;
+
+import org.apache.thrift.TException;
+import org.apache.thrift.protocol.TBinaryProtocol;
+import org.apache.thrift.protocol.TProtocol;
+import org.apache.thrift.transport.TFramedTransport;
+import org.apache.thrift.transport.TSocket;
+import org.apache.thrift.transport.TTransport;
+
+import com.yahoo.mapkeeper.BinaryResponse;
+import com.yahoo.mapkeeper.MapKeeper;
+import com.yahoo.mapkeeper.Record;
+import com.yahoo.mapkeeper.RecordListResponse;
+import com.yahoo.mapkeeper.ResponseCode;
+import com.yahoo.mapkeeper.ScanOrder;
+import com.yahoo.ycsb.ByteIterator;
+import com.yahoo.ycsb.DB;
+import com.yahoo.ycsb.StringByteIterator;
+import com.yahoo.ycsb.workloads.CoreWorkload;
+
+public class MapKeeperClient extends DB {
+    MapKeeper.Client c; 
+    boolean writeallfields;
+    static boolean initteddb = false;
+    private synchronized static void initDB(Properties p, MapKeeper.Client c) throws TException {
+        if(!initteddb) {
+            initteddb = true;
+            c.addMap(p.getProperty(CoreWorkload.TABLENAME_PROPERTY, CoreWorkload.TABLENAME_PROPERTY_DEFAULT));
+        }
+    }
+
+    public void init() {
+        TTransport tr = new TFramedTransport(new TSocket("localhost", 9090));
+        TProtocol proto = new TBinaryProtocol(tr);
+        c = new MapKeeper.Client(proto);
+        try {
+            tr.open();
+            initDB(getProperties(), c);
+        } catch(TException e) {
+            throw new RuntimeException(e);
+        }
+        writeallfields = Boolean.parseBoolean(getProperties().getProperty(CoreWorkload.WRITE_ALL_FIELDS_PROPERTY, 
+                    CoreWorkload.WRITE_ALL_FIELDS_PROPERTY_DEFAULT));
+    }
+
+    ByteBuffer encode(HashMap<String, ByteIterator> values) {
+        int len = 0;
+        for(String k : values.keySet()) {
+            len += (k.length() + 1 + values.get(k).bytesLeft() + 1);
+        }
+        byte[] array = new byte[len];
+        int i = 0;
+        for(String k : values.keySet()) {
+            for(int j = 0; j < k.length(); j++) {
+                array[i] = (byte)k.charAt(j);
+                i++;
+            }
+            array[i] = '\t'; // XXX would like to use sane delimiter (null, 254, 255, ...) but java makes this nearly impossible
+            i++;
+            ByteIterator v = values.get(k);
+            i = v.nextBuf(array, i);
+            array[i] = '\t';
+            i++;
+        }
+        array[array.length-1] = 0;
+        ByteBuffer buf = ByteBuffer.wrap(array);
+        buf.rewind();
+        return buf;
+    }
+    void decode(Set<String> fields, String tups, HashMap<String, ByteIterator> tup) {
+        String[] tok = tups.split("\\t");
+        if(tok.length == 0) { throw new IllegalStateException("split returned empty array!"); }
+        for(int i = 0; i < tok.length; i+=2) {
+            if(fields == null || fields.contains(tok[i])) {
+                if(tok.length < i+2) { throw new IllegalStateException("Couldn't parse tuple <" + tups + "> at index " + i); }
+                if(tok[i] == null || tok[i+1] == null) throw new NullPointerException("Key is " + tok[i] + " val is + " + tok[i+1]);
+                tup.put(tok[i], new StringByteIterator(tok[i+1]));
+            }
+        }
+        if(tok.length == 0) {
+            System.err.println("Empty tuple: " + tups);
+        }
+    }
+
+    int ycsbThriftRet(BinaryResponse succ, ResponseCode zero, ResponseCode one) {
+        return ycsbThriftRet(succ.responseCode, zero, one);
+    }
+    int ycsbThriftRet(ResponseCode rc, ResponseCode zero, ResponseCode one) {
+        return
+            rc == zero ? 0 :
+            rc == one  ? 1 : 2;
+    }
+    ByteBuffer bufStr(String str) {
+        ByteBuffer buf = ByteBuffer.wrap(str.getBytes());
+        return buf;
+    }
+    String strResponse(BinaryResponse buf) {
+        return new String(buf.value.array());
+    }
+
+    @Override
+    public int read(String table, String key, Set<String> fields,
+            HashMap<String, ByteIterator> result) {
+        try {
+            ByteBuffer buf = bufStr(key);
+
+            BinaryResponse succ = c.get(table, buf);
+
+            int ret = ycsbThriftRet(
+                    succ,
+                    ResponseCode.RecordExists,
+                    ResponseCode.RecordNotFound);
+
+            if(ret == 0) {
+                decode(fields, strResponse(succ), result);
+            }
+            return ret;
+        } catch(TException e) {
+            e.printStackTrace();
+            return 2;
+        }
+    }
+
+    @Override
+    public int scan(String table, String startkey, int recordcount,
+            Set<String> fields, Vector<HashMap<String, ByteIterator>> result) {
+        try {
+            //XXX what to pass in for nulls / zeros?
+            RecordListResponse res = c.scan(table, ScanOrder.Ascending, bufStr(startkey), true, null, false, recordcount, 0);
+            int ret = ycsbThriftRet(res.responseCode, ResponseCode.Success, ResponseCode.ScanEnded);
+            if(ret == 0) {
+                for(Record r : res.records) {
+                    HashMap<String, ByteIterator> tuple = new HashMap<String, ByteIterator>();
+                    // Note: r.getKey() and r.getValue() call special helper methods that trim the buffer
+                    // to an appropriate length, and memcpy it to a byte[].  Trying to manipulate the ByteBuffer
+                    // directly leads to trouble.
+                    tuple.put("key", new StringByteIterator(new String(r.getKey())));
+                    decode(fields, new String(r.getValue())/*strBuf(r.bufferForValue())*/, tuple);
+                    result.add(tuple);
+                }
+            }
+            return ret;
+        } catch(TException e) {
+            e.printStackTrace();
+            return 2;
+        }
+    }
+
+    @Override
+    public int update(String table, String key,
+            HashMap<String, ByteIterator> values) {
+        try {
+            if(!writeallfields) {
+                HashMap<String, ByteIterator> oldval = new HashMap<String, ByteIterator>();
+                read(table, key, null, oldval);
+                for(String k: values.keySet()) {
+                    oldval.put(k, values.get(k));
+                }
+                values = oldval;
+            }
+            ResponseCode succ = c.update(table, bufStr(key), encode(values));
+            return ycsbThriftRet(succ, ResponseCode.RecordExists, ResponseCode.RecordNotFound);
+        } catch(TException e) {
+            e.printStackTrace();
+            return 2;
+        }
+    }
+
+    @Override
+    public int insert(String table, String key,
+            HashMap<String, ByteIterator> values) {
+        try {
+            int ret = ycsbThriftRet(c.insert(table, bufStr(key), encode(values)), ResponseCode.Success, ResponseCode.RecordExists);
+            return ret;
+        } catch(TException e) {
+            e.printStackTrace();
+            return 2;
+        }
+    }
+
+    @Override
+    public int delete(String table, String key) {
+        try {
+            return ycsbThriftRet(c.remove(table, bufStr(key)), ResponseCode.Success, ResponseCode.RecordExists);
+        } catch(TException e) {
+            e.printStackTrace();
+            return 2;
+        }
+    }
+}
diff --git a/src/com/yahoo/ycsb/BasicDB.java b/src/com/yahoo/ycsb/BasicDB.java
index 19d6267..65f9704 100644
--- a/src/com/yahoo/ycsb/BasicDB.java
+++ b/src/com/yahoo/ycsb/BasicDB.java
@@ -67,7 +67,6 @@ public class BasicDB extends DB
 	 * Initialize any state for this DB.
 	 * Called once per DB instance; there is one DB instance per client thread.
 	 */
-	@SuppressWarnings("unchecked")
 	public void init()
 	{
 		verbose=Boolean.parseBoolean(getProperties().getProperty(VERBOSE, VERBOSE_DEFAULT));
@@ -79,7 +78,7 @@ public class BasicDB extends DB
 			Properties p=getProperties();
 			if (p!=null)
 			{
-				for (Enumeration e=p.propertyNames(); e.hasMoreElements(); )
+				for (Enumeration<?> e=p.propertyNames(); e.hasMoreElements(); )
 				{
 					String k=(String)e.nextElement();
 					System.out.println("\""+k+"\"=\""+p.getProperty(k)+"\"");
@@ -98,7 +97,7 @@ public class BasicDB extends DB
 	 * @param result A HashMap of field/value pairs for the result
 	 * @return Zero on success, a non-zero error code on error
 	 */
-	public int read(String table, String key, Set<String> fields, HashMap<String,String> result)
+	public int read(String table, String key, Set<String> fields, HashMap<String,ByteIterator> result)
 	{
 		delay();
 
@@ -133,7 +132,7 @@ public class BasicDB extends DB
 	 * @param result A Vector of HashMaps, where each HashMap is a set field/value pairs for one record
 	 * @return Zero on success, a non-zero error code on error
 	 */
-	public int scan(String table, String startkey, int recordcount, Set<String> fields, Vector<HashMap<String,String>> result)
+	public int scan(String table, String startkey, int recordcount, Set<String> fields, Vector<HashMap<String,ByteIterator>> result)
 	{
 		delay();
 
@@ -167,7 +166,7 @@ public class BasicDB extends DB
 	 * @param values A HashMap of field/value pairs to update in the record
 	 * @return Zero on success, a non-zero error code on error
 	 */
-	public int update(String table, String key, HashMap<String,String> values)
+	public int update(String table, String key, HashMap<String,ByteIterator> values)
 	{
 		delay();
 
@@ -196,7 +195,7 @@ public class BasicDB extends DB
 	 * @param values A HashMap of field/value pairs to insert in the record
 	 * @return Zero on success, a non-zero error code on error
 	 */
-	public int insert(String table, String key, HashMap<String,String> values)
+	public int insert(String table, String key, HashMap<String,ByteIterator> values)
 	{
 		delay();
 
diff --git a/src/com/yahoo/ycsb/ByteIterator.java b/src/com/yahoo/ycsb/ByteIterator.java
index e69de29..fd50743 100644
--- a/src/com/yahoo/ycsb/ByteIterator.java
+++ b/src/com/yahoo/ycsb/ByteIterator.java
@@ -0,0 +1,41 @@
+package com.yahoo.ycsb;
+
+import java.util.Iterator;
+
+public abstract class ByteIterator implements Iterator<Byte> {
+
+	@Override
+	public abstract boolean hasNext();
+
+	@Override
+	public Byte next() {
+		throw new UnsupportedOperationException();
+		//return nextByte();
+	}
+
+	public abstract byte nextByte();
+        /** @return byte offset immediately after the last valid byte */
+	public int nextBuf(byte[] buf, int buf_off) {
+		int sz = buf_off;
+		while(sz < buf.length && hasNext()) {
+			buf[sz] = nextByte();
+			sz++;
+		}
+		return sz;
+	}
+
+	public abstract long bytesLeft();
+	
+	@Override
+	public void remove() {
+		throw new UnsupportedOperationException();
+	}
+
+	/** Consumes remaining contents of this object, and returns them as a string. */
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		while(this.hasNext()) { sb.append((char)nextByte()); }
+		return sb.toString();
+	}
+
+}
diff --git a/src/com/yahoo/ycsb/CommandLine.java b/src/com/yahoo/ycsb/CommandLine.java
index c6fb13d..3f77dd6 100644
--- a/src/com/yahoo/ycsb/CommandLine.java
+++ b/src/com/yahoo/ycsb/CommandLine.java
@@ -114,7 +114,7 @@ public class CommandLine
 		  System.exit(0);
 	       }
 	       
-	       for (Enumeration e=myfileprops.propertyNames(); e.hasMoreElements(); )
+	       for (Enumeration<?> e=myfileprops.propertyNames(); e.hasMoreElements(); )
 	       {
 		  String prop=(String)e.nextElement();
 		  
@@ -173,7 +173,7 @@ public class CommandLine
 	    System.exit(0);
 	 }
 
-	 for (Enumeration e=props.propertyNames(); e.hasMoreElements(); )
+	 for (Enumeration<?> e=props.propertyNames(); e.hasMoreElements(); )
 	 {
 	    String prop=(String)e.nextElement();
 	    
@@ -195,7 +195,7 @@ public class CommandLine
 
 	 try 
 	 {
-	    Class dbclass = classLoader.loadClass(dbname);
+	    Class<?> dbclass = classLoader.loadClass(dbname);
 	    db=(DB)dbclass.newInstance();
 	 }
 	 catch (Exception e) 
@@ -293,10 +293,10 @@ public class CommandLine
 		     }
 		  }
 		  
-		  HashMap<String,String> result=new HashMap<String,String>();
+		  HashMap<String,ByteIterator> result=new HashMap<String,ByteIterator>();
 		  int ret=db.read(table,tokens[1],fields,result);
 		  System.out.println("Return code: "+ret);
-		  for (Map.Entry<String,String> ent : result.entrySet())
+		  for (Map.Entry<String,ByteIterator> ent : result.entrySet())
 		  {
 		     System.out.println(ent.getKey()+"="+ent.getValue());
 		  }
@@ -322,7 +322,7 @@ public class CommandLine
 		     }
 		  }
 		  
-		  Vector<HashMap<String,String>> results=new Vector<HashMap<String,String>>();
+		  Vector<HashMap<String,ByteIterator>> results=new Vector<HashMap<String,ByteIterator>>();
 		  int ret=db.scan(table,tokens[1],Integer.parseInt(tokens[2]),fields,results);
 		  System.out.println("Return code: "+ret);
 		  int record=0;
@@ -334,10 +334,10 @@ public class CommandLine
 		  {
 		     System.out.println("--------------------------------");
 		  }
-		  for (HashMap<String,String> result : results)
+		  for (HashMap<String,ByteIterator> result : results)
 		  {
 		     System.out.println("Record "+(record++));
-		     for (Map.Entry<String,String> ent : result.entrySet())
+		     for (Map.Entry<String,ByteIterator> ent : result.entrySet())
 		     {
 			System.out.println(ent.getKey()+"="+ent.getValue());
 		     }
@@ -353,12 +353,12 @@ public class CommandLine
 	       }
 	       else 
 	       {
-		  HashMap<String,String> values=new HashMap<String,String>();
+		  HashMap<String,ByteIterator> values=new HashMap<String,ByteIterator>();
 
 		  for (int i=2; i<tokens.length; i++)
 		  {
 		     String[] nv=tokens[i].split("=");
-		     values.put(nv[0],nv[1]);
+		     values.put(nv[0],new StringByteIterator(nv[1]));
 		  }
 
 		  int ret=db.update(table,tokens[1],values);
@@ -373,12 +373,12 @@ public class CommandLine
 	       }
 	       else 
 	       {
-		  HashMap<String,String> values=new HashMap<String,String>();
+		  HashMap<String,ByteIterator> values=new HashMap<String,ByteIterator>();
 
 		  for (int i=2; i<tokens.length; i++)
 		  {
 		     String[] nv=tokens[i].split("=");
-		     values.put(nv[0],nv[1]);
+		     values.put(nv[0],new StringByteIterator(nv[1]));
 		  }
 
 		  int ret=db.insert(table,tokens[1],values);
diff --git a/src/com/yahoo/ycsb/DB.java b/src/com/yahoo/ycsb/DB.java
index d790d13..7ad38fc 100644
--- a/src/com/yahoo/ycsb/DB.java
+++ b/src/com/yahoo/ycsb/DB.java
@@ -90,7 +90,7 @@ public abstract class DB
 	 * @param result A HashMap of field/value pairs for the result
 	 * @return Zero on success, a non-zero error code on error or "not found".
 	 */
-	public abstract int read(String table, String key, Set<String> fields, HashMap<String,String> result);
+	public abstract int read(String table, String key, Set<String> fields, HashMap<String,ByteIterator> result);
 
 	/**
 	 * Perform a range scan for a set of records in the database. Each field/value pair from the result will be stored in a HashMap.
@@ -102,8 +102,12 @@ public abstract class DB
 	 * @param result A Vector of HashMaps, where each HashMap is a set field/value pairs for one record
 	 * @return Zero on success, a non-zero error code on error.  See this class's description for a discussion of error codes.
 	 */
-	public abstract int scan(String table, String startkey, int recordcount, Set<String> fields, Vector<HashMap<String,String>> result);
-	
+	public abstract int scan(String table, String startkey, int recordcount, Set<String> fields, Vector<HashMap<String,ByteIterator>> result);
+
+	public int scan(String table, String startkey, String stopkey, Set<String> fields, Vector<HashMap<String,ByteIterator>> result) {
+		throw new UnsupportedOperationException();
+	}
+
 	/**
 	 * Update a record in the database. Any field/value pairs in the specified values HashMap will be written into the record with the specified
 	 * record key, overwriting any existing values with the same field name.
@@ -113,7 +117,7 @@ public abstract class DB
 	 * @param values A HashMap of field/value pairs to update in the record
 	 * @return Zero on success, a non-zero error code on error.  See this class's description for a discussion of error codes.
 	 */
-	public abstract int update(String table, String key, HashMap<String,String> values);
+	public abstract int update(String table, String key, HashMap<String,ByteIterator> values);
 
 	/**
 	 * Insert a record in the database. Any field/value pairs in the specified values HashMap will be written into the record with the specified
@@ -124,7 +128,7 @@ public abstract class DB
 	 * @param values A HashMap of field/value pairs to insert in the record
 	 * @return Zero on success, a non-zero error code on error.  See this class's description for a discussion of error codes.
 	 */
-	public abstract int insert(String table, String key, HashMap<String,String> values);
+	public abstract int insert(String table, String key, HashMap<String,ByteIterator> values);
 
 	/**
 	 * Delete a record from the database. 
diff --git a/src/com/yahoo/ycsb/DBWrapper.java b/src/com/yahoo/ycsb/DBWrapper.java
index 8ca7a89..c6bcfaa 100644
--- a/src/com/yahoo/ycsb/DBWrapper.java
+++ b/src/com/yahoo/ycsb/DBWrapper.java
@@ -81,7 +81,7 @@ public class DBWrapper extends DB
 	 * @param result A HashMap of field/value pairs for the result
 	 * @return Zero on success, a non-zero error code on error
 	 */
-	public int read(String table, String key, Set<String> fields, HashMap<String,String> result)
+	public int read(String table, String key, Set<String> fields, HashMap<String,ByteIterator> result)
 	{
 		long st=System.currentTimeMillis();
 		int res=_db.read(table,key,fields,result);
@@ -101,7 +101,7 @@ public class DBWrapper extends DB
 	 * @param result A Vector of HashMaps, where each HashMap is a set field/value pairs for one record
 	 * @return Zero on success, a non-zero error code on error
 	 */
-	public int scan(String table, String startkey, int recordcount, Set<String> fields, Vector<HashMap<String,String>> result)
+	public int scan(String table, String startkey, int recordcount, Set<String> fields, Vector<HashMap<String,ByteIterator>> result)
 	{
 		long st=System.currentTimeMillis();
 		int res=_db.scan(table,startkey,recordcount,fields,result);
@@ -120,7 +120,7 @@ public class DBWrapper extends DB
 	 * @param values A HashMap of field/value pairs to update in the record
 	 * @return Zero on success, a non-zero error code on error
 	 */
-	public int update(String table, String key, HashMap<String,String> values)
+	public int update(String table, String key, HashMap<String,ByteIterator> values)
 	{
 		long st=System.currentTimeMillis();
 		int res=_db.update(table,key,values);
@@ -139,7 +139,7 @@ public class DBWrapper extends DB
 	 * @param values A HashMap of field/value pairs to insert in the record
 	 * @return Zero on success, a non-zero error code on error
 	 */
-	public int insert(String table, String key, HashMap<String,String> values)
+	public int insert(String table, String key, HashMap<String,ByteIterator> values)
 	{
 		long st=System.currentTimeMillis();
 		int res=_db.insert(table,key,values);
diff --git a/src/com/yahoo/ycsb/RandomByteIterator.java b/src/com/yahoo/ycsb/RandomByteIterator.java
index e69de29..ffb198f 100644
--- a/src/com/yahoo/ycsb/RandomByteIterator.java
+++ b/src/com/yahoo/ycsb/RandomByteIterator.java
@@ -0,0 +1,71 @@
+package com.yahoo.ycsb;
+
+import java.util.Random;
+
+public class RandomByteIterator extends ByteIterator {
+	static Random random=new Random();
+	long len;
+	long off;
+	int buf_off;
+	byte[] buf;
+	
+	@Override
+	public boolean hasNext() {
+		return (off + buf_off) < len;
+	}
+
+	private void fillBytesImpl(byte[] buf, int base) {
+		int bytes = random.nextInt();
+		try {
+			buf[base+0] = (byte)(((bytes      ) & 31) + ' ');
+			buf[base+1] = (byte)(((bytes >> 5 ) & 31) + ' ');
+			buf[base+2] = (byte)(((bytes >> 10) & 31) + ' ');
+			buf[base+3] = (byte)(((bytes >> 15) & 31) + ' ');
+			buf[base+4] = (byte)(((bytes >> 20) & 31) + ' ');
+			buf[base+5] = (byte)(((bytes >> 25) & 31) + ' ');
+		} catch (ArrayIndexOutOfBoundsException e) { /* ignore it */ }
+	}
+	
+	private void fillBytes() {
+		if(buf_off ==  buf.length) {
+			fillBytesImpl(buf, 0);
+			buf_off = 0;
+			off += buf.length;
+		}
+	}
+	
+	public RandomByteIterator(long len) {
+		this.len = len;
+		this.buf = new byte[6];
+		this.buf_off = buf.length;
+		fillBytes();
+		this.off = 0;
+	}
+
+	public byte nextByte() {
+		fillBytes();
+		buf_off++;
+		return buf[buf_off-1];
+	}
+	@Override
+	public int nextBuf(byte[] b, int buf_off) {
+		int ret;
+		if(len - off < b.length - buf_off) {
+			ret = (int)(len - off);
+		} else {
+			ret = b.length - buf_off;
+		}
+		int i;
+		for(i = 0; i < ret; i+=6) {
+			fillBytesImpl(b, i+buf_off);
+		}
+		off+=ret;
+		return ret + buf_off;
+	}
+	
+	
+	@Override
+	public long bytesLeft() {
+		return len - off;
+	}
+}
diff --git a/src/com/yahoo/ycsb/StringByteIterator.java b/src/com/yahoo/ycsb/StringByteIterator.java
index e69de29..69496e7 100644
--- a/src/com/yahoo/ycsb/StringByteIterator.java
+++ b/src/com/yahoo/ycsb/StringByteIterator.java
@@ -0,0 +1,27 @@
+package com.yahoo.ycsb;
+
+public class StringByteIterator extends ByteIterator {
+	String str;
+	int off;
+	public StringByteIterator(String s) {
+		this.str = s;
+		this.off = 0;
+	}
+	@Override
+	public boolean hasNext() {
+		return off < str.length();
+	}
+
+	@Override
+	public byte nextByte() {
+		byte ret = (byte)str.charAt(off);
+		off++;
+		return ret;
+	}
+
+	@Override
+	public long bytesLeft() {
+		return str.length() - off;
+	}
+
+}
diff --git a/src/com/yahoo/ycsb/Utils.java b/src/com/yahoo/ycsb/Utils.java
index f94ebc0..ab81826 100644
--- a/src/com/yahoo/ycsb/Utils.java
+++ b/src/com/yahoo/ycsb/Utils.java
@@ -17,6 +17,8 @@
 
 package com.yahoo.ycsb;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
 import java.util.Random;
 
 /**
@@ -24,12 +26,30 @@ import java.util.Random;
  */
 public class Utils
 {
-	static Random random=new Random();
+    static Random random=new Random();
+    static Field str_val;
+    static Field str_len;
+    private static void ensure_init() throws NoSuchFieldException, IllegalAccessException {
+        if(str_val == null || str_len == null) {
+            str_len = String.class.getDeclaredField("count");
+            str_val = String.class.getDeclaredField("value");
+
+            str_len.setAccessible(true);
+            str_val.setAccessible(true);
+            Field str_len_mod = Field.class.getDeclaredField("modifiers");
+            Field str_val_mod = Field.class.getDeclaredField("modifiers");
+            str_len_mod.setAccessible(true);
+            str_val_mod.setAccessible(true);
+            str_len_mod.setInt(str_len, str_len.getModifiers() & ~Modifier.FINAL);
+            str_val_mod.setInt(str_val, str_val.getModifiers() & ~Modifier.FINAL);
+        }
+    }
+
 	
       /**
        * Generate a random ASCII string of a given length.
        */
-      public static String ASCIIString(int length)
+      public static String ASCIIStringOld(int length)
       {
 	 int interval='~'-' '+1;
 	
@@ -45,12 +65,55 @@ public class Utils
         return new String(buf);
       }
       
+      
+      public static String ASCIIString(int length)
+      {
+	      
+	      char[]buf = new char[length];
+	      int i;
+	      for(i = 0; i < length-6; i+=6) {
+		      int bytes = random.nextInt();
+		      buf[i]   = (char)(((bytes      ) & 31) + ' ');
+		      buf[i+1] = (char)(((bytes >> 5 ) & 31) + ' ');
+		      buf[i+2] = (char)(((bytes >> 10) & 31) + ' ');
+		      buf[i+3] = (char)(((bytes >> 15) & 31) + ' ');
+		      buf[i+4] = (char)(((bytes >> 20) & 31) + ' ');
+		      buf[i+5] = (char)(((bytes >> 25) & 31) + ' ');
+	      }
+	      int d = length - i;
+	      if(d > 0) {
+		      int bytes = random.nextInt();
+		      if(d >= 1) { buf[i]   = (char) (((bytes      ) & 31) + ' '); }
+		      if(d >= 2) { buf[i+1] = (char) (((bytes >> 5 ) & 31) + ' '); }
+		      if(d >= 3) { buf[i+2] = (char) (((bytes >> 10) & 31) + ' '); }
+		      if(d >= 4) { buf[i+3] = (char) (((bytes >> 15) & 31) + ' '); }
+		      if(d >= 5) { buf[i+4] = (char) (((bytes >> 20) & 31) + ' '); }
+	      }
+	      try {
+                  if(buf.length > 1024 * 1024) {
+                      ensure_init();
+		      String s = new String();
+                      str_val.set(s, buf);
+                      str_len.set(s, buf.length);
+		      return s;
+                  } else {
+                      return new String(buf);
+                  }
+	      } catch (Exception e) {
+		      System.out.println("fields ");
+		      Field fs[] = String.class.getDeclaredFields();
+		      for(Field f : fs) {
+			      System.out.println(f);
+		      }
+		      throw new IllegalStateException(e);
+	      }
+      }
       /**
        * Hash an integer value.
        */
-      public static int hash(int val)
+      public static long hash(long val)
       {
-	 return FNVhash32(val);
+	 return FNVhash64(val);
       }
 	
       public static final int FNV_offset_basis_32=0x811c9dc5;
diff --git a/src/com/yahoo/ycsb/generator/ConstantIntegerGenerator.java b/src/com/yahoo/ycsb/generator/ConstantIntegerGenerator.java
index e69de29..76ed9be 100644
--- a/src/com/yahoo/ycsb/generator/ConstantIntegerGenerator.java
+++ b/src/com/yahoo/ycsb/generator/ConstantIntegerGenerator.java
@@ -0,0 +1,31 @@
+/**
+ * 
+ */
+package com.yahoo.ycsb.generator;
+
+/**
+ * A trivial integer generator that always returns the same value.
+ * 
+ * @author sears
+ *
+ */
+public class ConstantIntegerGenerator extends IntegerGenerator {
+	private final int i;
+	/**
+	 * @param i The integer that this generator will always return.
+	 */
+	public ConstantIntegerGenerator(int i) {
+		this.i = i;
+	}
+
+	@Override
+	public int nextInt() {
+		return i;
+	}
+
+	@Override
+	public double mean() {
+		return i;
+	}
+
+}
diff --git a/src/com/yahoo/ycsb/generator/CounterGenerator.java b/src/com/yahoo/ycsb/generator/CounterGenerator.java
index 70ce1b0..11db1cf 100644
--- a/src/com/yahoo/ycsb/generator/CounterGenerator.java
+++ b/src/com/yahoo/ycsb/generator/CounterGenerator.java
@@ -45,5 +45,8 @@ public class CounterGenerator extends IntegerGenerator
 		return lastint;
 	}
 
-
+	@Override
+	public double mean() {
+		throw new UnsupportedOperationException("Can't compute mean of non-stationary distribution!");
+	}
 }
diff --git a/src/com/yahoo/ycsb/generator/ExponentialGenerator.java b/src/com/yahoo/ycsb/generator/ExponentialGenerator.java
index e69de29..5abe3c2 100644
--- a/src/com/yahoo/ycsb/generator/ExponentialGenerator.java
+++ b/src/com/yahoo/ycsb/generator/ExponentialGenerator.java
@@ -0,0 +1,88 @@
+/**                                                                                                                                                                                
+ * Copyright (c) 2011 Yahoo! Inc. All rights reserved.                                                                                                                             
+ *                                                                                                                                                                                 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you                                                                                                             
+ * may not use this file except in compliance with the License. You                                                                                                                
+ * may obtain a copy of the License at                                                                                                                                             
+ *                                                                                                                                                                                 
+ * http://www.apache.org/licenses/LICENSE-2.0                                                                                                                                      
+ *                                                                                                                                                                                 
+ * Unless required by applicable law or agreed to in writing, software                                                                                                             
+ * distributed under the License is distributed on an "AS IS" BASIS,                                                                                                               
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or                                                                                                                 
+ * implied. See the License for the specific language governing                                                                                                                    
+ * permissions and limitations under the License. See accompanying                                                                                                                 
+ * LICENSE file.                                                                                                                                                                   
+ */
+
+package com.yahoo.ycsb.generator;
+
+import java.util.Random;
+
+/**
+ * A generator of an exponential distribution. It produces a sequence
+ * of time intervals (integers) according to an exponential
+ * distribution.  Smaller intervals are more frequent than larger
+ * ones, and there is no bound on the length of an interval.  When you
+ * construct an instance of this class, you specify a parameter gamma,
+ * which corresponds to the rate at which events occur.
+ * Alternatively, 1/gamma is the average length of an interval.
+ */
+public class ExponentialGenerator extends IntegerGenerator
+{
+	public static final String EXPONENTIAL_MEAN_PROPERTY="exponentialmean";
+	public static final String EXPONENTIAL_MEAN_DEFAULT="1000000.0";  // The mean time to access is 1,000,000 impressions. 
+
+	/**
+	 * The exponential constant to use.
+	 */
+	double _gamma;	
+
+	Random _random;
+
+	/******************************* Constructors **************************************/
+
+	/**
+	 * Create an exponential generator with a mean arrival rate of
+	 * gamma.  (And half life of 1/gamma).
+	 */
+	public ExponentialGenerator(double mean)
+	{
+		_gamma = 1.0/mean;
+		_random = new Random();
+	}
+
+	public ExponentialGenerator()
+	{
+		this(1.0/Double.parseDouble(EXPONENTIAL_MEAN_DEFAULT));
+	}
+	/****************************************************************************************/
+	
+	/** 
+	 * Generate the next item. this distribution will be skewed toward lower integers; e.g. 0 will
+	 * be the most popular, 1 the next most popular, etc.
+	 * @param itemcount The number of items in the distribution.
+	 * @return The next item in the sequence.
+	 */
+	@Override
+	public int nextInt()
+	{
+		return (int)nextLong();
+	}
+
+	/**
+	 * Generate the next item as a long.
+	 * 
+	 * @param itemcount The number of items in the distribution.
+	 * @return The next item in the sequence.
+	 */
+	public long nextLong()
+	{
+		return (long) (-Math.log(_random.nextDouble()) / _gamma);
+	}
+
+	@Override
+	public double mean() {
+		return 1.0/_gamma;
+	}
+}
diff --git a/src/com/yahoo/ycsb/generator/HistogramGenerator.java b/src/com/yahoo/ycsb/generator/HistogramGenerator.java
index e69de29..0b10e56 100644
--- a/src/com/yahoo/ycsb/generator/HistogramGenerator.java
+++ b/src/com/yahoo/ycsb/generator/HistogramGenerator.java
@@ -0,0 +1,100 @@
+/**
+ * 
+ */
+package com.yahoo.ycsb.generator;
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Random;
+import com.yahoo.ycsb.generator.IntegerGenerator;
+
+/**
+ * Generate integers according to a histogram distribution.  The histogram
+ * buckets are of width one, but the values are multiplied by a block size.
+ * Therefore, instead of drawing sizes uniformly at random within each
+ * bucket, we always draw the largest value in the current bucket, so the value
+ * drawn is always a multiple of block_size.
+ * 
+ * The minimum value this distribution returns is block_size (not zero).
+ * 
+ * Modified Nov 19 2010 by sears
+ * 
+ * @author snjones
+ *
+ */
+public class HistogramGenerator extends IntegerGenerator {
+
+	long block_size;
+	long[] buckets;
+	long area;
+	Random rand = new Random();
+	long weighted_area = 0;
+	double mean_size = 0;
+	
+	public HistogramGenerator(String histogramfile) throws IOException {
+	BufferedReader in = new BufferedReader(new FileReader(histogramfile));
+	String str;
+	String[] line;
+	
+	ArrayList<Integer> a = new ArrayList<Integer>();
+
+	str = in.readLine();
+	if(str == null) {
+		throw new IOException("Empty input file!\n");
+	}
+	line = str.split("\t");
+	if(line[0].compareTo("BlockSize") != 0) {
+		throw new IOException("First line of histogram is not the BlockSize!\n");
+	}
+	block_size = Integer.parseInt(line[1]);
+	
+	while((str = in.readLine()) != null){
+		// [0] is the bucket, [1] is the value
+		line = str.split("\t");
+		
+		a.add(Integer.parseInt(line[0]), Integer.parseInt(line[1]));
+	}
+	buckets = new long[a.size()];
+	for(int i = 0; i < a.size(); i++) {
+		buckets[i] = a.get(i);
+	}
+
+	in.close();
+	init();
+	}
+
+	public HistogramGenerator(long[] buckets, int block_size) {
+		this.block_size = block_size;
+		this.buckets = buckets;
+		init();
+	}
+	private void init() {
+		for(int i = 0; i < buckets.length; i++) {
+			area += buckets[i];
+			weighted_area = i * buckets[i];
+		}
+		// calculate average file size
+		mean_size = ((double)block_size) * ((double)weighted_area) / (double)(area);
+	}
+
+	@Override
+	public int nextInt() {
+		int number = rand.nextInt((int)area);
+		int i;
+		
+		for(i = 0; i < (buckets.length - 1); i++){
+			number -= buckets[i];
+			if(number <= 0){
+				return (int)((i+1)*block_size);
+			}
+		}
+		
+		return (int)(i * block_size);
+	}
+
+	@Override
+	public double mean() {
+		return mean_size;
+	}
+}
diff --git a/src/com/yahoo/ycsb/generator/HotspotIntegerGenerator.java b/src/com/yahoo/ycsb/generator/HotspotIntegerGenerator.java
index dd12db7..6a76bb5 100644
--- a/src/com/yahoo/ycsb/generator/HotspotIntegerGenerator.java
+++ b/src/com/yahoo/ycsb/generator/HotspotIntegerGenerator.java
@@ -24,7 +24,7 @@ import java.util.Random;
  * the percentage of the of the interval which comprises the hot set and
  * the percentage of operations that access the hot set. Numbers of the hot set are
  * always smaller than any number in the cold set. Elements from the hot set and
- * the cold set are chose using a uniform distribution.
+ * the cold set are chosen using a uniform distribution.
  * 
  * @author sudipto
  *
@@ -116,4 +116,10 @@ public class HotspotIntegerGenerator extends IntegerGenerator {
     return hotOpnFraction;
   }
 
+@Override
+public double mean() {
+	return hotOpnFraction * (lowerBound + hotInterval/2.0)
+			+ (1 - hotOpnFraction) * (lowerBound + hotInterval + coldInterval/2.0);
+}
+
 }
diff --git a/src/com/yahoo/ycsb/generator/IntegerGenerator.java b/src/com/yahoo/ycsb/generator/IntegerGenerator.java
index 8268f14..a49d9b4 100644
--- a/src/com/yahoo/ycsb/generator/IntegerGenerator.java
+++ b/src/com/yahoo/ycsb/generator/IntegerGenerator.java
@@ -67,4 +67,8 @@ public abstract class IntegerGenerator extends Generator
 	{
 		return lastint;
 	}
+	/**
+	 * Return the expected value (mean) of the values this generator will return.
+	 */
+	public abstract double mean();
 }
diff --git a/src/com/yahoo/ycsb/generator/ScrambledZipfianGenerator.java b/src/com/yahoo/ycsb/generator/ScrambledZipfianGenerator.java
index 0f5731b..4ce52e1 100644
--- a/src/com/yahoo/ycsb/generator/ScrambledZipfianGenerator.java
+++ b/src/com/yahoo/ycsb/generator/ScrambledZipfianGenerator.java
@@ -30,8 +30,7 @@ import com.yahoo.ycsb.Utils;
  */
 public class ScrambledZipfianGenerator extends IntegerGenerator 
 {
-	public static final double ZETAN=26.46902820178302;
-        public static final double USED_ZIPFIAN_CONSTANT=0.99;
+	public static final double ZETAN=52.93805640344461;
 	public static final long ITEM_COUNT=10000000000L;
 	
 	ZipfianGenerator gen;
@@ -73,23 +72,18 @@ public class ScrambledZipfianGenerator extends IntegerGenerator
 */
 	
 	/**
-	 * Create a zipfian generator for items between min and max (inclusive) for the specified zipfian constant. If you 
-	 * use a zipfian constant other than 0.99, this will take a long time to complete because we need to recompute zeta.
+	 * Create a zipfian generator for items between min and max (inclusive) for the specified zipfian constant.
 	 * @param min The smallest integer to generate in the sequence.
 	 * @param max The largest integer to generate in the sequence.
 	 * @param _zipfianconstant The zipfian constant to use.
 	 */
-        public ScrambledZipfianGenerator(long min, long max, double _zipfianconstant)
+	ScrambledZipfianGenerator(long min, long max, double _zipfianconstant)
 	{
+		//not public as we only support one value of zipfianconstant for which we have precomputed zeta
 		_min=min;
 		_max=max;
 		_itemcount=_max-_min+1;
-		if (_zipfianconstant == USED_ZIPFIAN_CONSTANT) 
-		{
-		    gen=new ZipfianGenerator(0,ITEM_COUNT,_zipfianconstant,ZETAN);
-		} else {
-		    gen=new ZipfianGenerator(0,ITEM_COUNT,_zipfianconstant);
-		}
+		gen=new ZipfianGenerator(0,ITEM_COUNT,_zipfianconstant,ZETAN);
 	}
 	
 	/**************************************************************************************************/
@@ -115,10 +109,6 @@ public class ScrambledZipfianGenerator extends IntegerGenerator
 	
 	public static void main(String[] args)
 	{
-	    double newzetan = ZipfianGenerator.zetastatic(ITEM_COUNT,ZipfianGenerator.ZIPFIAN_CONSTANT);
-	    System.out.println("zetan: "+newzetan);
-	    System.exit(0);
-
 		ScrambledZipfianGenerator gen=new ScrambledZipfianGenerator(10000);
 		
 		for (int i=0; i<1000000; i++)
@@ -126,4 +116,12 @@ public class ScrambledZipfianGenerator extends IntegerGenerator
 			System.out.println(""+gen.nextInt());
 		}
 	}
+
+	/**
+	 * since the values are scrambled (hopefully uniformly), the mean is simply the middle of the range.
+	 */
+	@Override
+	public double mean() {
+		return ((double)(((long)_min) +(long)_max))/2.0;
+	}
 }
diff --git a/src/com/yahoo/ycsb/generator/SkewedLatestGenerator.java b/src/com/yahoo/ycsb/generator/SkewedLatestGenerator.java
index 1b86097..6d07c5f 100644
--- a/src/com/yahoo/ycsb/generator/SkewedLatestGenerator.java
+++ b/src/com/yahoo/ycsb/generator/SkewedLatestGenerator.java
@@ -53,4 +53,9 @@ public class SkewedLatestGenerator extends IntegerGenerator
 
 	}
 
+	@Override
+	public double mean() {
+		throw new UnsupportedOperationException("Can't compute mean of non-stationary distribution!");
+	}
+
 }
diff --git a/src/com/yahoo/ycsb/generator/UniformIntegerGenerator.java b/src/com/yahoo/ycsb/generator/UniformIntegerGenerator.java
index 74ebba0..a6ae08a 100644
--- a/src/com/yahoo/ycsb/generator/UniformIntegerGenerator.java
+++ b/src/com/yahoo/ycsb/generator/UniformIntegerGenerator.java
@@ -50,4 +50,8 @@ public class UniformIntegerGenerator extends IntegerGenerator
 		return ret;
 	}
 
+	@Override
+	public double mean() {
+		return ((double)((long)(_lb + (long)_ub))) / 2.0;
+	}
 }
diff --git a/src/com/yahoo/ycsb/generator/ZipfianGenerator.java b/src/com/yahoo/ycsb/generator/ZipfianGenerator.java
index cc0ade8..5a4c019 100644
--- a/src/com/yahoo/ycsb/generator/ZipfianGenerator.java
+++ b/src/com/yahoo/ycsb/generator/ZipfianGenerator.java
@@ -316,4 +316,12 @@ public class ZipfianGenerator extends IntegerGenerator
 	{
 		new ZipfianGenerator(ScrambledZipfianGenerator.ITEM_COUNT);
 	}
+
+	/**
+	 * @todo Implement ZipfianGenerator.mean()
+	 */
+	@Override
+	public double mean() {
+		throw new UnsupportedOperationException("@todo implement ZipfianGenerator.mean()");
+	}
 }
diff --git a/src/com/yahoo/ycsb/workloads/CoreWorkload.java b/src/com/yahoo/ycsb/workloads/CoreWorkload.java
index dd1dbd0..679f7ab 100644
--- a/src/com/yahoo/ycsb/workloads/CoreWorkload.java
+++ b/src/com/yahoo/ycsb/workloads/CoreWorkload.java
@@ -17,11 +17,15 @@
 
 package com.yahoo.ycsb.workloads;
 
+import java.io.IOException;
 import java.util.Properties;
 import com.yahoo.ycsb.*;
+import com.yahoo.ycsb.generator.ConstantIntegerGenerator;
 import com.yahoo.ycsb.generator.CounterGenerator;
 import com.yahoo.ycsb.generator.DiscreteGenerator;
+import com.yahoo.ycsb.generator.ExponentialGenerator;
 import com.yahoo.ycsb.generator.Generator;
+import com.yahoo.ycsb.generator.HistogramGenerator;
 import com.yahoo.ycsb.generator.HotspotIntegerGenerator;
 import com.yahoo.ycsb.generator.IntegerGenerator;
 import com.yahoo.ycsb.generator.ScrambledZipfianGenerator;
@@ -85,18 +89,41 @@ public class CoreWorkload extends Workload
 	int fieldcount;
 
 	/**
+	 * The name of the property for the field length distribution. Options are "uniform", "zipfian" (favoring short records), "constant", and "histogram".
+	 * 
+	 * If "uniform", "zipfian" or "constant", the maximum field length will be that specified by the fieldlength property.  If "histogram", then the
+	 * histogram will be read from the filename specified in the "fieldlengthhistogram" property.
+	 */
+	public static final String FIELD_LENGTH_DISTRIBUTION_PROPERTY="fieldlengthdistribution";
+	/**
+	 * The default field length distribution.
+	 */
+	public static final String FIELD_LENGTH_DISTRIBUTION_PROPERTY_DEFAULT = "constant";
+
+	/**
 	 * The name of the property for the length of a field in bytes.
 	 */
 	public static final String FIELD_LENGTH_PROPERTY="fieldlength";
-	
 	/**
-	 * The default length of a field in bytes.
+	 * The default maximum length of a field in bytes.
 	 */
 	public static final String FIELD_LENGTH_PROPERTY_DEFAULT="100";
 
-	int fieldlength;
+	/**
+	 * The name of a property that specifies the filename containing the field length histogram (only used if fieldlengthdistribution is "histogram").
+	 */
+	public static final String FIELD_LENGTH_HISTOGRAM_FILE_PROPERTY = "fieldlengthhistogram";
+	/**
+	 * The default filename containing a field length histogram.
+	 */
+	public static final String FIELD_LENGTH_HISTOGRAM_FILE_PROPERTY_DEFAULT = "hist.txt";
 
 	/**
+	 * Generator object that produces field lengths.  The value of this depends on the properties that start with "FIELD_LENGTH_".
+	 */
+	IntegerGenerator fieldlengthgenerator;
+	
+	/**
 	 * The name of the property for deciding whether to read one field (false) or all fields (true) of a record.
 	 */
 	public static final String READ_ALL_FIELDS_PROPERTY="readallfields";
@@ -247,6 +274,29 @@ public class CoreWorkload extends Workload
 
 	int recordcount;
 	
+	protected static IntegerGenerator getFieldLengthGenerator(Properties p) throws WorkloadException{
+		IntegerGenerator fieldlengthgenerator;
+		String fieldlengthdistribution = p.getProperty(FIELD_LENGTH_DISTRIBUTION_PROPERTY, FIELD_LENGTH_DISTRIBUTION_PROPERTY_DEFAULT);
+		int fieldlength=Integer.parseInt(p.getProperty(FIELD_LENGTH_PROPERTY,FIELD_LENGTH_PROPERTY_DEFAULT));
+		String fieldlengthhistogram = p.getProperty(FIELD_LENGTH_HISTOGRAM_FILE_PROPERTY, FIELD_LENGTH_HISTOGRAM_FILE_PROPERTY_DEFAULT);
+		if(fieldlengthdistribution.compareTo("constant") == 0) {
+			fieldlengthgenerator = new ConstantIntegerGenerator(fieldlength);
+		} else if(fieldlengthdistribution.compareTo("uniform") == 0) {
+			fieldlengthgenerator = new UniformIntegerGenerator(1, fieldlength);
+		} else if(fieldlengthdistribution.compareTo("zipfian") == 0) {
+			fieldlengthgenerator = new ZipfianGenerator(1, fieldlength);
+		} else if(fieldlengthdistribution.compareTo("histogram") == 0) {
+			try {
+				fieldlengthgenerator = new HistogramGenerator(fieldlengthhistogram);
+			} catch(IOException e) {
+				throw new WorkloadException("Couldn't read field length histogram file: "+fieldlengthhistogram, e);
+			}
+		} else {
+			throw new WorkloadException("Unknown field length distribution \""+fieldlengthdistribution+"\"");
+		}
+		return fieldlengthgenerator;
+	}
+	
 	/**
 	 * Initialize the scenario. 
 	 * Called once, in the main client thread, before any operations are started.
@@ -254,8 +304,10 @@ public class CoreWorkload extends Workload
 	public void init(Properties p) throws WorkloadException
 	{
 		table = p.getProperty(TABLENAME_PROPERTY,TABLENAME_PROPERTY_DEFAULT);
+		
 		fieldcount=Integer.parseInt(p.getProperty(FIELD_COUNT_PROPERTY,FIELD_COUNT_PROPERTY_DEFAULT));
-		fieldlength=Integer.parseInt(p.getProperty(FIELD_LENGTH_PROPERTY,FIELD_LENGTH_PROPERTY_DEFAULT));
+		fieldlengthgenerator = CoreWorkload.getFieldLengthGenerator(p);
+		
 		double readproportion=Double.parseDouble(p.getProperty(READ_PROPORTION_PROPERTY,READ_PROPORTION_PROPERTY_DEFAULT));
 		double updateproportion=Double.parseDouble(p.getProperty(UPDATE_PROPORTION_PROPERTY,UPDATE_PROPORTION_PROPERTY_DEFAULT));
 		double insertproportion=Double.parseDouble(p.getProperty(INSERT_PROPORTION_PROPERTY,INSERT_PROPORTION_PROPERTY_DEFAULT));
@@ -330,18 +382,23 @@ public class CoreWorkload extends Workload
 		{
 			keychooser=new SkewedLatestGenerator(transactioninsertkeysequence);
 		}
+		else if (requestdistrib.compareTo("exponential")==0)
+		{
+			double mean = Double.parseDouble(p.getProperty(ExponentialGenerator.EXPONENTIAL_MEAN_PROPERTY, ExponentialGenerator.EXPONENTIAL_MEAN_DEFAULT));
+			keychooser=new ExponentialGenerator(mean);
+		}
 		else if (requestdistrib.equals("hotspot")) 
 		{
-      double hotsetfraction = Double.parseDouble(p.getProperty(
-          HOTSPOT_DATA_FRACTION, HOTSPOT_DATA_FRACTION_DEFAULT));
-      double hotopnfraction = Double.parseDouble(p.getProperty(
-          HOTSPOT_OPN_FRACTION, HOTSPOT_OPN_FRACTION_DEFAULT));
-      keychooser = new HotspotIntegerGenerator(0, recordcount - 1, 
-          hotsetfraction, hotopnfraction);
-    }
+			double hotsetfraction = Double.parseDouble(p.getProperty(
+					HOTSPOT_DATA_FRACTION, HOTSPOT_DATA_FRACTION_DEFAULT));
+			double hotopnfraction = Double.parseDouble(p.getProperty(
+					HOTSPOT_OPN_FRACTION, HOTSPOT_OPN_FRACTION_DEFAULT));
+			keychooser = new HotspotIntegerGenerator(0, recordcount - 1, 
+					hotsetfraction, hotopnfraction);
+		}
 		else
 		{
-			throw new WorkloadException("Unknown distribution \""+requestdistrib+"\"");
+			throw new WorkloadException("Unknown request distribution \""+requestdistrib+"\"");
 		}
 
 		fieldchooser=new UniformIntegerGenerator(0,fieldcount-1);
@@ -360,27 +417,44 @@ public class CoreWorkload extends Workload
 		}
 	}
 
-	/**
-	 * Do one insert operation. Because it will be called concurrently from multiple client threads, this 
-	 * function must be thread safe. However, avoid synchronized, or the threads will block waiting for each 
-	 * other, and it will be difficult to reach the target throughput. Ideally, this function would have no side
-	 * effects other than DB operations.
-	 */
-	public boolean doInsert(DB db, Object threadstate)
-	{
-		int keynum=keysequence.nextInt();
+	public String buildKeyName(long keynum) {
 		if (!orderedinserts)
 		{
 			keynum=Utils.hash(keynum);
 		}
-		String dbkey="user"+keynum;
-		HashMap<String,String> values=new HashMap<String,String>();
+		return "user"+keynum;
+	}
+	HashMap<String, ByteIterator> buildValues() {
+		HashMap<String,ByteIterator> values=new HashMap<String,ByteIterator>();
+	
 		for (int i=0; i<fieldcount; i++)
 		{
 			String fieldkey="field"+i;
-			String data=Utils.ASCIIString(fieldlength);
+			ByteIterator data= new RandomByteIterator(fieldlengthgenerator.nextInt()); //.ASCIIString(fieldlengthgenerator.nextInt());
 			values.put(fieldkey,data);
 		}
+		return values;
+	}
+	HashMap<String, ByteIterator> buildUpdate() {
+		//update a random field
+		HashMap<String, ByteIterator> values=new HashMap<String,ByteIterator>();
+		String fieldname="field"+fieldchooser.nextString();
+		ByteIterator data = new RandomByteIterator(fieldlengthgenerator.nextInt());
+		values.put(fieldname,data);
+		return values;
+	}
+
+	/**
+	 * Do one insert operation. Because it will be called concurrently from multiple client threads, this 
+	 * function must be thread safe. However, avoid synchronized, or the threads will block waiting for each 
+	 * other, and it will be difficult to reach the target throughput. Ideally, this function would have no side
+	 * effects other than DB operations.
+	 */
+	public boolean doInsert(DB db, Object threadstate)
+	{
+		int keynum=keysequence.nextInt();
+		String dbkey = buildKeyName(keynum);
+		HashMap<String, ByteIterator> values = buildValues();
 		if (db.insert(table,dbkey,values) == 0)
 			return true;
 		else
@@ -431,12 +505,8 @@ public class CoreWorkload extends Workload
 		}
 		while (keynum>transactioninsertkeysequence.lastInt());
 		
-		if (!orderedinserts)
-		{
-			keynum=Utils.hash(keynum);
-		}
-		String keyname="user"+keynum;
-
+		String keyname = buildKeyName(keynum);
+		
 		HashSet<String> fields=null;
 
 		if (!readallfields)
@@ -448,7 +518,7 @@ public class CoreWorkload extends Workload
 			fields.add(fieldname);
 		}
 
-		db.read(table,keyname,fields,new HashMap<String,String>());
+		db.read(table,keyname,fields,new HashMap<String,ByteIterator>());
 	}
 	
 	public void doTransactionReadModifyWrite(DB db)
@@ -461,11 +531,7 @@ public class CoreWorkload extends Workload
 		}
 		while (keynum>transactioninsertkeysequence.lastInt());
 		
-		if (!orderedinserts)
-		{
-			keynum=Utils.hash(keynum);
-		}
-		String keyname="user"+keynum;
+		String keyname = buildKeyName(keynum);
 
 		HashSet<String> fields=null;
 
@@ -478,31 +544,24 @@ public class CoreWorkload extends Workload
 			fields.add(fieldname);
 		}
 		
-		HashMap<String,String> values=new HashMap<String,String>();
+		HashMap<String,ByteIterator> values;
 
 		if (writeallfields)
 		{
 		   //new data for all the fields
-		   for (int i=0; i<fieldcount; i++)
-		   {
-		      String fieldname="field"+i;
-		      String data=Utils.ASCIIString(fieldlength);		   
-		      values.put(fieldname,data);
-		   }
+		   values = buildValues();
 		}
 		else
 		{
 		   //update a random field
-		   String fieldname="field"+fieldchooser.nextString();
-		   String data=Utils.ASCIIString(fieldlength);		   
-		   values.put(fieldname,data);
+		   values = buildUpdate();
 		}
 
 		//do the transaction
 		
 		long st=System.currentTimeMillis();
 
-		db.read(table,keyname,fields,new HashMap<String,String>());
+		db.read(table,keyname,fields,new HashMap<String,ByteIterator>());
 		
 		db.update(table,keyname,values);
 
@@ -521,11 +580,7 @@ public class CoreWorkload extends Workload
 		}
 		while (keynum>transactioninsertkeysequence.lastInt());
 
-		if (!orderedinserts)
-		{
-			keynum=Utils.hash(keynum);
-		}
-		String startkeyname="user"+keynum;
+		String startkeyname = buildKeyName(keynum);
 		
 		//choose a random scan length
 		int len=scanlength.nextInt();
@@ -541,7 +596,7 @@ public class CoreWorkload extends Workload
 			fields.add(fieldname);
 		}
 
-		db.scan(table,startkeyname,len,fields,new Vector<HashMap<String,String>>());
+		db.scan(table,startkeyname,len,fields,new Vector<HashMap<String,ByteIterator>>());
 	}
 
 	public void doTransactionUpdate(DB db)
@@ -554,30 +609,18 @@ public class CoreWorkload extends Workload
 		}
 		while (keynum>transactioninsertkeysequence.lastInt());
 
-		if (!orderedinserts)
-		{
-			keynum=Utils.hash(keynum);
-		}
-		String keyname="user"+keynum;
+		String keyname = buildKeyName(keynum);
 
-		HashMap<String,String> values=new HashMap<String,String>();
+		HashMap<String,ByteIterator> values;
 
 		if (writeallfields)
 		{
 		   //new data for all the fields
-		   for (int i=0; i<fieldcount; i++)
-		   {
-		      String fieldname="field"+i;
-		      String data=Utils.ASCIIString(fieldlength);		   
-		      values.put(fieldname,data);
-		   }
+		   values = buildValues();
 		}
 		else
 		{
-		   //update a random field
-		   String fieldname="field"+fieldchooser.nextString();
-		   String data=Utils.ASCIIString(fieldlength);		   
-		   values.put(fieldname,data);
+		   values = buildUpdate();
 		}
 
 		db.update(table,keyname,values);
@@ -587,19 +630,10 @@ public class CoreWorkload extends Workload
 	{
 		//choose the next key
 		int keynum=transactioninsertkeysequence.nextInt();
-		if (!orderedinserts)
-		{
-			keynum=Utils.hash(keynum);
-		}
-		String dbkey="user"+keynum;
-		
-		HashMap<String,String> values=new HashMap<String,String>();
-		for (int i=0; i<fieldcount; i++)
-		{
-			String fieldkey="field"+i;
-			String data=Utils.ASCIIString(fieldlength);
-			values.put(fieldkey,data);
-		}
+
+		String dbkey = buildKeyName(keynum);
+
+		HashMap<String, ByteIterator> values = buildValues();
 		db.insert(table,dbkey,values);
 	}
 }
